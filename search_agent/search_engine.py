import json
import pdb

from langchain_community.llms import Ollama
from langchain_ollama import ChatOllama
from htmlrag import clean_html, build_block_tree, EmbedHTMLPruner, BM25HTMLPruner, GenHTMLPruner

from selenium.common.exceptions import NoSuchElementException, TimeoutException, ElementClickInterceptedException, \
    WebDriverException, ElementNotInteractableException
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
import logging
from dotenv import load_dotenv
import os
from transformers import AutoTokenizer
from selenium.webdriver.support.wait import WebDriverWait

from agents.llm import LLM, PROMPTS

# Maximum number of words in a node when constructing the block tree for pruning with the embedding model
MAX_NODE_WORDS_EMBED = 10
# MAX_NODE_WORDS_EMBED = 256 # a recommended setting for real-world HTML documents
# Maximum number of tokens in the output HTML document pruned with the embedding model
MAX_CONTEXT_WINDOW_EMBED = 60
# MAX_CONTEXT_WINDOW_EMBED = 6144 # a recommended setting for real-world HTML documents
# Maximum number of words in a node when constructing the block tree for pruning with the generative model
MAX_NODE_WORDS_GEN = 5
# MAX_NODE_WORDS_GEN = 128 # a recommended setting for real-world HTML documents
# Maximum number of tokens in the output HTML document pruned with the generative model
MAX_CONTEXT_WINDOW_GEN = 32

# MAX_CONTEXT_WINDOW_GEN = 4096 # a recommended setting for real-world HTML documents

load_dotenv()
HF_TOKEN = os.getenv("HF_TOKEN")


class SearchEngine:
    def __init__(self):
        self.llm = LLM(bind_create_job_element=False)
        self.driver = None
        self.llm.bind_tools([self.fill_form_with_llm_response], ['fill_form_with_llm_response'])

    def apply_for_job(self, url_for_job):
        self.driver = webdriver.Chrome()
        self.driver.get(url_for_job)
        forms = self.find_all_elements(element_type="form", parent_element_or_driver=self.driver)
        for form in forms:
            json_res = self.process_form(form)
            if json_res:
                print(json_res)
                self.fill_form_with_llm_response(self.driver, json_res, {})

    @staticmethod
    def find_all_elements(element_type, parent_element_or_driver):
        try:
            WebDriverWait(parent_element_or_driver, 10).until(
                EC.presence_of_all_elements_located((By.TAG_NAME, element_type)))
            return parent_element_or_driver.find_elements(By.TAG_NAME, element_type)
        except Exception as e:
            print(e)
            return []

    def process_form(self, form):
        html = form.get_attribute("outerHTML")

        block_tree, simplified_html = build_block_tree(html, max_node_words=MAX_NODE_WORDS_EMBED)
        query = PROMPTS.get_analyze_html_prompt(simplified_html, block_tree)
        json_response = self.llm.get_llm_response(query)
        if hasattr(json_response, "content"):
            response = self.llm.get_llm_response(
                PROMPTS.get_completion_from_schema_prompt(schema=json_response))
            if hasattr(response, "content"):
                return response.content
        return None

    @staticmethod
    def fill_form_with_llm_response(driver, llm_response, user_data, submit=True):
        """
        Fills out a form on a webpage based on the JSON schema generated by an LLM.

        :param driver: Selenium WebDriver instance.
        :param llm_response: JSON schema as a string generated by the LLM.
        :param user_data: Dictionary mapping field names in the schema to user-provided values.
        :param submit: Whether to click the submit button after filling the form.
        """
        try:
            pdb.set_trace()
            schema = json.loads(llm_response)
        except json.JSONDecodeError as e:
            raise ValueError("Invalid JSON schema from LLM response.") from e

        if not schema.get("properties"):
            raise ValueError("The JSON schema does not contain any properties.")

        for field_name, field_properties in schema["properties"].items():
            try:
                locator = field_properties.get("locator", {})
                element = None
                if "id" in locator:
                    element = WebDriverWait(driver, 10).until(
                        EC.presence_of_element_located((By.ID, locator["id"]))
                    )
                elif "class" in locator:
                    element = WebDriverWait(driver, 10).until(
                        EC.presence_of_element_located((By.CLASS_NAME, locator["class"]))
                    )
                else:
                    print(f"No valid locator provided for field: {field_name}")
                    continue

                if field_name in user_data:
                    element.clear()
                    element.send_keys(user_data[field_name])
                else:
                    print(f"No data provided for field: {field_name}")

            except Exception as e:
                print(f"Error interacting with field '{field_name}': {e}")

        if submit:
            try:
                submit_button = driver.find_element(By.TAG_NAME, "button")
                submit_button.click()
            except Exception as e:
                print(f"Error clicking the submit button: {e}")


if __name__ == '__main__':
    search_engine = SearchEngine()
    search_engine.apply_for_job(
        "https://www.upwind.io/careers/co/tel-aviv/BA.04A/backend-developer/all?coref=1.10.s07_945#jobs")
